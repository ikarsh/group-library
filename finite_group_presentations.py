import itertools
from typing import List, Tuple
from finite_group import FiniteGroup
from free_group import FreeGroup, FreeGroupElement, FreeGroupGenerator, commutator
from utils import prime_power_base
import galois


def C(n: int) -> FiniteGroup:
    F = FreeGroup(("a",))
    (a,) = F.gens()
    kernel = F.normal_subgroup([a**n])
    return F / kernel


def dir_prod(gps: List[FiniteGroup]) -> FiniteGroup:
    F = FreeGroup(
        tuple(
            f"a{i}_{j}"
            for i in range(len(gps))
            for j in range(gps[i].free_group.rank())
        )
    )
    relations: List[FreeGroupElement] = []

    gens: List[Tuple[FreeGroupGenerator, ...]] = []
    idx = 0
    for i in range(len(gps)):
        gens.append(F.gens()[idx : idx + gps[i].free_group.rank()])
        idx += gps[i].free_group.rank()

    for i, gp in enumerate(gps):
        for gen in gp.kernel.gens():
            relations.append(gen.substitute(F, gens[i]))

    for X, Y in itertools.combinations(gens, 2):
        for a in X:
            for b in Y:
                relations.append(commutator(a, b))

    return F / F.normal_subgroup(relations)


def D(n: int) -> FiniteGroup:
    F = FreeGroup(("a", "b"))
    a, b = F.gens()
    return F / F.normal_subgroup([a**n, b**2, a.conjugate(b) * a])


def GQ(n: int) -> FiniteGroup:
    """
    The generalized quaternion group of order 2^n.
    It starts with the quaternions at n == 3.
    Source: https://groupprops.subwiki.org/wiki/Generalized_quaternion_group
    """
    assert n >= 3
    F = FreeGroup(("a", "b"))
    a, b = F.gens()
    return F / F.normal_subgroup(
        [a ** (2 ** (n - 1)), a.conjugate(b) * a, a ** (2 ** (n - 2)) * b ** (-2)]
    )


def S(n: int) -> FiniteGroup:
    """
    Generated by 2-cycle and n-cycle.
    Source: https://math.stackexchange.com/questions/3972026/what-are-the-relations-in-this-presentation-of-s-n
    """
    F = FreeGroup(("a", "b"))
    a, b = F.gens()
    return F / F.normal_subgroup(
        [a**2, b**n, (a * b) ** (n - 1), commutator(a, b) ** 3]
        + [commutator(a, b**k) ** 2 for k in range(2, n // 2 + 1)]
    )


def S_(
    n: int,
) -> FiniteGroup:
    """
    Alternative presentation of S_n, generated by two-cycles.
    This is less efficient as it has more generators.
    Source: https://warwick.ac.uk/fac/sci/maths/people/staff/fbouyer/presentation_of_group.pdf
    """
    F = FreeGroup(tuple(f"a{i}" for i in range(n - 1)))
    gens = F.gens()
    relations: List[FreeGroupElement] = []
    for g in gens:
        relations.append(g**2)
    for (i, g1), (j, g2) in itertools.combinations(enumerate(gens), 2):
        assert i != j
        if abs(i - j) == 1:
            relations.append((g1 * g2) ** 3)
        else:
            relations.append(commutator(g1, g2))
    return F / F.normal_subgroup(relations)


# TODO find a presentation with two generators
def A(n: int) -> FiniteGroup:  # Generated by (1, 2, i)
    """
    Source: https://math.stackexchange.com/questions/122720/presentations-for-alternating-groups
    """
    F = FreeGroup(n - 2)
    gens = F.gens()
    relations: List[FreeGroupElement] = []
    for g in gens:
        relations.append(g**3)
    for g, h in itertools.combinations(gens, 2):
        relations.append((g * h) ** 2)
    return F / F.normal_subgroup(relations)


def GL2(q: int) -> FiniteGroup:
    """
    This is the group GL2(F_q), for q a prime power.
    Source: https://web.iitd.ac.in/~rksharma/Research%20Publications/Journal/S%20Maheshwari%20general%20linear%20groups.pdf
    (Theorem 5.1 for q != 3 odd, Corollary 5.2 for q == 3, Theorem 4.1 for q != 2 even, and remark 4.2 for q == 2)
    """
    if q == 2:
        F2 = FreeGroup(("a", "b"))
        a, b = F2.gens()
        return F2 / F2.normal_subgroup([a**2, b**2, (a * b) ** 3])

    p = prime_power_base(q)

    F = FreeGroup(("a", "b", "c"))
    a, b, c = F.gens()

    Fq = galois.GF(q)
    alpha = Fq.primitive_element

    def log_base_alpha(x: galois.FieldArray) -> int:
        if x == 0:
            raise ValueError("log undefined for 0")
        for i in range(q):
            if alpha**i == x:
                return i
        assert False, "unreachable"

    if q % 2 == 0:
        a_list = [(b * c) ** (-i) * (b * a * b) * (b * c) ** i for i in range(q)]
        b_list = [(b * c) ** j * a * (b * c) ** (-j) for j in range(q)]
        return F / F.normal_subgroup(
            [
                a**2,
                b**2,
                c ** (2 * (q - 1)),
                commutator(a, c**2),
                commutator(b, c**2),
                (a * b) ** 3,
                (b * c) ** (q - 1),
                *(
                    (a * a_list[i] * a) ** (-1) * (b * a * b) * b_list[i] * (b * a * b)
                    for i in range(1, q)
                ),
                a_list[1]
                * a_list[2]
                * a_list[log_base_alpha(alpha + alpha**2)] ** (-1),
            ]
        )

    # These are a_i and b_j. We include a_0 and b_0 in the list but do not use them.
    a_list = [
        (b * c) ** (-i) * (b * (b * c) ** ((q - 1) // 2) * a * b) * (b * c) ** i
        for i in range(q)
    ]
    b_list = [
        (b * c) ** j * ((b * c) ** ((q - 1) // 2) * a) * (b * c) ** (-j)
        for j in range(q)
    ]

    if q == 3:
        return F / F.normal_subgroup(
            [
                a**2,
                b**2,
                c**4,
                commutator(a, c**2),
                commutator(b, c**2),
                (a * b) ** 3,
                (b * c * a) ** p,
                (b * c) ** 2,
                a_list[1] ** 2 * a_list[2] ** (-1),
                *(commutator(b_list[q - 1], b_list[i]) for i in range(1, q - 1)),
                a_list[q - 1] ** (-1)
                * b_list[q - 1]
                * a_list[q - 1] ** (-1)
                * (b * (b * c) ** ((q - 1) // 2)) ** (-1),
                *(
                    a
                    * a_list[i]
                    * a
                    * (b_list[i].conjugate(a_list[q - 1] ** (-1))) ** (-1)
                    for i in range(1, q)
                ),
                *(
                    b_list[i].conjugate(
                        a_list[q - 1] * b_list[q - 1] ** (-1) * a_list[q - 1]
                    )
                    * a_list[i]
                    for i in range(1, q)
                ),
            ]
        )

    return F / F.normal_subgroup(
        [
            a**2,
            b**2,
            c ** (2 * (q - 1)),
            commutator(a, c**2),
            commutator(b, c**2),
            (a * b) ** 3,
            ((b * c) ** ((q - 1) // 2) * a) ** p,
            (b * c) ** (q - 1),
            commutator(a_list[1], a_list[2]),
            (a_list[1] * a_list[2]) * a_list[log_base_alpha(alpha + alpha**2)] ** (-1),
            *(
                a_list[1] ** i * a_list[log_base_alpha(i * alpha)] ** (-1)
                for i in range(2, p)
            ),
            *(commutator(b_list[i], b_list[q - 1]) for i in range(1, q - 1)),
            a_list[q - 1] ** (-1)
            * b_list[q - 1]
            * a_list[q - 1] ** (-1)
            * (b * (b * c) ** ((q - 1) // 2)) ** (-1),
            *(
                a * a_list[i] * a * (b_list[i].conjugate(a_list[q - 1] ** (-1))) ** (-1)
                for i in range(1, q)
            ),
            *(
                b_list[i].conjugate(
                    a_list[q - 1] * b_list[q - 1] ** (-1) * a_list[q - 1]
                )
                * a_list[i]
                for i in range(1, q)
            ),
        ]
    )


def SL2(n: int) -> FiniteGroup:
    """
    This is the group SL2(Z/n). Defined only for odd n.
    Source: https://www.cambridge.org/core/services/aop-cambridge-core/content/view/EB7CA1AEF520E171A4C027AD677C6C5A/S0008414X00038359a.pdf/presentations-of-the-groups-sl2-m-and-psl2-m.pdf
    """
    if not n > 1:
        raise ValueError()
    if n % 2 == 0:
        raise NotImplementedError("SL2(Z/n) is only implemented for odd n")
    F = FreeGroup(("a", "b"))
    a, b = F.gens()
    return F / F.normal_subgroup(
        [
            a**n * b ** (-2),
            (a * b) ** 3 * b ** (-2),
            (a ** ((n + 1) // 2) * b * a**4 * b) ** 2 * b ** (-2),
        ]
    )


def PSL2(n: int) -> FiniteGroup:
    """
    This is PSL2(Z/n). Defined only for odd n.
    Source: the same as for SL2.
    """
    if not n > 1:
        raise ValueError()
    if n % 2 == 0:
        raise NotImplementedError("PSL2(Z/n) is only implemented for odd n")
    F = FreeGroup(("a", "b"))
    a, b = F.gens()
    return F / F.normal_subgroup(
        [
            a**n,
            (a * b) ** 3 * b ** (-2),
            (a ** ((n + 1) // 2) * b * a**4 * b) ** 2,
        ]
    )


def UT(n: int, m: int) -> FiniteGroup:
    """
    The group of upper unitriangular n x n matrices over Z/mZ.
    Source: https://sites.math.duke.edu/~dasgupta/papers/Unipotent.pdf
    """
    F = FreeGroup(n - 1)
    gens = F.gens()
    commutators = [commutator(gens[i], gens[i + 1]) for i in range(n - 2)]
    relations: List[FreeGroupElement] = []
    for i in range(n - 1):
        relations.append(gens[i] ** m)
    for i in range(n - 1):
        for j in range(i + 2, n - 1):
            relations.append(commutator(gens[i], gens[j]))
    for i in range(n - 2):
        relations.append(commutator(gens[i], commutators[i]))
        relations.append(commutator(gens[i + 1], commutators[i]))
    if m % 2 == 0:
        for i in range(n - 3):
            relations.append(commutator(commutators[i], commutators[i + 1]))
    return F / F.normal_subgroup(relations)


# Also interesting:
# Presentations of the Special and General Linear Groups - Francis T.A.
