import itertools
from typing import List, Tuple
from finite_group import FiniteGroup
from free_group import FreeGroup, FreeGroupElement, FreeGroupGenerator, commutator
from subgroup_of_free_group import NormalFiniteIndexSubgroupOfFreeGroup


def C(n: int) -> FiniteGroup:
    F = FreeGroup(("a",))
    (a,) = F.gens()
    kernel = F.normal_subgroup([a**n])
    assert isinstance(kernel, NormalFiniteIndexSubgroupOfFreeGroup)
    return kernel.quotient()


def dir_prod(gps: List[FiniteGroup]) -> FiniteGroup:
    F = FreeGroup(
        tuple(
            f"a{i}_{j}"
            for i in range(len(gps))
            for j in range(gps[i].free_group.rank())
        )
    )
    relations: List[FreeGroupElement] = []

    gens: List[Tuple[FreeGroupGenerator, ...]] = []
    idx = 0
    for i in range(len(gps)):
        gens.append(F.gens()[idx : idx + gps[i].free_group.rank()])
        idx += gps[i].free_group.rank()

    for i, gp in enumerate(gps):
        for gen in gp.kernel.gens():
            relations.append(gen.substitute(F, gens[i]))

    for X, Y in itertools.combinations(gens, 2):
        for a in X:
            for b in Y:
                relations.append(commutator(a, b))

    kernel = F.normal_subgroup(relations)
    assert isinstance(kernel, NormalFiniteIndexSubgroupOfFreeGroup)
    return kernel.quotient()


def D(n: int) -> FiniteGroup:
    F = FreeGroup(("a", "b"))
    a, b = F.gens()
    kernel = F.normal_subgroup([a**n, b**2, a.conjugate(b) * a])
    assert isinstance(kernel, NormalFiniteIndexSubgroupOfFreeGroup)
    return kernel.quotient()


def GQ(n: int) -> FiniteGroup:
    """
    The generalized quaternion group of order 2^n.
    It starts with the quaternions at n == 3.
    Source: https://groupprops.subwiki.org/wiki/Generalized_quaternion_group
    """
    assert n >= 3
    F = FreeGroup(("a", "b"))
    a, b = F.gens()
    kernel = F.normal_subgroup(
        [a ** (2 ** (n - 1)), a.conjugate(b) * a, a ** (2 ** (n - 2)) * b ** (-2)]
    )
    assert isinstance(kernel, NormalFiniteIndexSubgroupOfFreeGroup)
    return kernel.quotient()


def S(n: int) -> FiniteGroup:
    """
    Generated by 2-cycle and n-cycle.
    Source: https://math.stackexchange.com/questions/3972026/what-are-the-relations-in-this-presentation-of-s-n
    """
    F = FreeGroup(("a", "b"))
    a, b = F.gens()
    kernel = F.normal_subgroup(
        [a**2, b**n, (a * b) ** (n - 1), commutator(a, b) ** 3]
        + [commutator(a, b**k) ** 2 for k in range(2, n // 2 + 1)]
    )
    assert isinstance(kernel, NormalFiniteIndexSubgroupOfFreeGroup)
    return kernel.quotient()


def S_(
    n: int,
) -> FiniteGroup:
    """
    Alternative presentation of S_n, generated by two-cycles.
    This is less efficient as it has more generators.
    Source: https://warwick.ac.uk/fac/sci/maths/people/staff/fbouyer/presentation_of_group.pdf
    """
    F = FreeGroup(tuple(f"a{i}" for i in range(n - 1)))
    gens = F.gens()
    relations: List[FreeGroupElement] = []
    for g in gens:
        relations.append(g**2)
    for (i, g1), (j, g2) in itertools.combinations(enumerate(gens), 2):
        assert i != j
        if abs(i - j) == 1:
            relations.append((g1 * g2) ** 3)
        else:
            relations.append(commutator(g1, g2))
    kernel = F.normal_subgroup(relations)
    assert isinstance(kernel, NormalFiniteIndexSubgroupOfFreeGroup)
    return kernel.quotient()


# TODO find a presentation with two generators
def A(n: int) -> FiniteGroup:  # Generated by (1, 2, i)
    """
    Source: https://math.stackexchange.com/questions/122720/presentations-for-alternating-groups
    """
    F = FreeGroup(n - 2)
    gens = F.gens()
    relations: List[FreeGroupElement] = []
    for g in gens:
        relations.append(g**3)
    for g, h in itertools.combinations(gens, 2):
        relations.append((g * h) ** 2)
    kernel = F.normal_subgroup(relations)
    assert isinstance(kernel, NormalFiniteIndexSubgroupOfFreeGroup)
    return kernel.quotient()


def SL2(n: int) -> FiniteGroup:
    """
    This is the group SL2(Z/n). Defined only for odd n.
    Source: https://www.cambridge.org/core/services/aop-cambridge-core/content/view/EB7CA1AEF520E171A4C027AD677C6C5A/S0008414X00038359a.pdf/presentations-of-the-groups-sl2-m-and-psl2-m.pdf
    """
    if not n > 1:
        raise ValueError()
    if n % 2 == 0:
        raise NotImplementedError("SL2(Z/n) is only implemented for odd n")
    F = FreeGroup(("a", "b"))
    a, b = F.gens()
    kernel = F.normal_subgroup(
        [
            a**n * b ** (-2),
            (a * b) ** 3 * b ** (-2),
            (a ** ((n + 1) // 2) * b * a**4 * b) ** 2 * b ** (-2),
        ]
    )
    assert isinstance(kernel, NormalFiniteIndexSubgroupOfFreeGroup)
    return kernel.quotient()


def PSL2(n: int) -> FiniteGroup:
    """
    This is PSL2(Z/n). Defined only for odd n.
    Source: the same as for SL2.
    """
    if not n > 1:
        raise ValueError()
    if n % 2 == 0:
        raise NotImplementedError("PSL2(Z/n) is only implemented for odd n")
    F = FreeGroup(("a", "b"))
    a, b = F.gens()
    kernel = F.normal_subgroup(
        [
            a**n,
            (a * b) ** 3 * b ** (-2),
            (a ** ((n + 1) // 2) * b * a**4 * b) ** 2,
        ]
    )
    assert isinstance(kernel, NormalFiniteIndexSubgroupOfFreeGroup)
    return kernel.quotient()
