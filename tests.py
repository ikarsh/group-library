import itertools
from math import factorial, prod
from typing import TYPE_CHECKING, List


from finite_group import FiniteGroup, FiniteGroupElement
from finite_group_presentations import A, C, D, GQ, PSL2, S, SL2, dir_prod
from free_group import FreeGroup, FreeGroupElement, commutator
from subgroup_of_free_group import NormalFiniteIndexSubgroupOfFreeGroup

if TYPE_CHECKING:

    def factor(n: int) -> dict[int, int]: ...
    def euler_phi(n: int) -> int: ...

else:
    from sympy import factorint, totient

    euler_phi = totient
    factor = factorint


def test_free_group_identities():
    F = FreeGroup(("a", "b", "c"))
    a, b, c = F.gens()
    x, y, z = (a * b * ~a * b * c**2, b ** (-3) * c * a * b, a * b * c**5 * ~a)
    e = F.identity()

    # Group axioms
    assert x * e == e * x == x
    assert x * ~x == ~x * x == e
    assert (x * y) * z == x * (y * z)
    assert (x * y) ** (-1) == y ** (-1) * x ** (-1)

    # Exponentiation
    assert x**5 == x * x * x * x * x
    assert y ** (-2) == ~y * ~y

    # Conjugation
    assert x.conjugate(y) == y * x * ~y
    assert x.conjugate(e) == x
    assert e.conjugate(x) == e
    assert (x * y).conjugate(z) == x.conjugate(z) * y.conjugate(z)
    assert x.conjugate(y * z) == x.conjugate(z).conjugate(y)

    # Commutators
    c = commutator
    assert c(x, y) == x * y * ~x * ~y
    assert c(x, y) == ~c(y, x)
    assert c(x * y, z) == c(x, c(y, z)) * c(y, z) * c(x, z)
    assert (
        c(~x, ~y) == (~x) ** 2 * c(x, ~y) * (~y) ** 2 * c(y, x) * x**2 * c(~x, y) * y**2
    )

    # Jacobi identity
    assert (
        c(z.conjugate(y), c(x, y))
        * c(y.conjugate(x), c(z, x))
        * c(x.conjugate(z), c(y, z))
        == e
    )


def test_subgroup_creation():
    F = FreeGroup(("a", "b"))
    words = list(F.__iter__(max_len=4))
    for w1, w2 in itertools.combinations(words, 2):
        F.subgroup([w1, w2])


def test_subgroup_new_generators():
    # Tests that the subgroup manages to form a basis, that generates the original and is no longer than it.
    # TODO: Add proofs the new generators are generated by the originals.

    # I am not sure how to test that the new generators are free.
    # Technically, returning the original generators would satisfy this test...

    F = FreeGroup(("a", "b"))
    a, b = F.gens()

    lst: List[List[FreeGroupElement]] = [
        [a, b],
        [a, b ** (-10)],
        [a * b, b * a],
        [(a * b) ** 2, a],
        [(a * b) ** 3, b],
        [b * a * ~b, a**3 * ~b],
        [a**2, b**3, commutator(a, b)],
        [(a * b) ** 10, commutator(a, b) ** 3, b**1, b.conjugate(a)],
        [a**2 * b**3 * a ** (-2), b**3, commutator(a, b.conjugate(a**5))],
    ]

    for gens in lst:
        H = F.subgroup(gens)
        free_gens = H.gens()
        assert len(free_gens) <= len(gens)
        for gen in gens:
            word = H.express(gen)
            assert word is not None
            for g, _ in word:
                assert g in free_gens

            w = F.identity()
            for g, n in word:
                w *= g**n
            assert w == gen


def test_subgroup_element_containement():
    F = FreeGroup(("a", "b"))
    a, b = F.gens()
    x, y = (a**3 * b ** (-2) * a * b**2, a * b * a * b * a * b)

    # contains_element
    assert F.full_subgroup().contains_element(a)
    assert not F.empty_subgroup().contains_element(a)
    assert F.subgroup([x, y]).contains_element(x * y * x ** (-2) * y**3)
    assert not F.subgroup([a**2, b]).contains_element(a)


def test_normal_subgroup():
    F2 = FreeGroup(("a", "b"))
    a, b = F2.gens()

    assert F2.full_subgroup().is_normal()
    assert F2.empty_subgroup().is_normal()
    assert not F2.subgroup([a]).is_normal()
    assert F2.subgroup(
        [a, a.conjugate(b), a.conjugate(b**2), a.conjugate(b**3), b**4]
    ).is_normal()

    # Generate S3
    assert F2.normal_subgroup([a**2, b**3, b.conjugate(a) * a]).is_normal()


def test_finite_index_subgroup():
    F2 = FreeGroup(("a", "b"))
    a, b = F2.gens()

    # This is S5.
    kernel = F2.normal_subgroup(
        [a**2, b**5, (a * b) ** 4, commutator(a, b) ** 3, commutator(a, b**2) ** 2]
    )
    assert isinstance(kernel, NormalFiniteIndexSubgroupOfFreeGroup)
    G = kernel.quotient()
    assert G.order() == 120

    h = FiniteGroupElement(G, a * b * a)

    # H = F2.subgroup(N.gens() + [a * b * a])
    assert h.order() == 5

    conjugates = h.conjugates()
    assert h in conjugates

    # There are six 5-syllow subgroups of S5!
    distinct: List[FiniteGroupElement] = []
    for conj in conjugates:
        if conj not in distinct:
            distinct.append(conj)
    assert len(distinct) == 24
    # assert len(distinct) == 6

    for conj in conjugates:
        assert conj.order() == 5

    for gen in G.gens():
        for conj in conjugates:
            assert conj.conjugate(gen) in conjugates
            assert conj.conjugate(~gen) in conjugates

    # ... return this later
    # assert H.core() == F2.intersect_subgroups(conjugates) == N


def test_finite_groups():
    # This verifies the sizes of finite groups, and that the ranks of the kernels for them satisfy the formula:
    # rank(N_G) == |G| * (n - 1) + 1, where N_G = ker(F_n -> G).
    def verify_formula(G: FiniteGroup):
        assert G.kernel.rank() == G.order() * (G.free_group.rank() - 1) + 1

    for n in range(2, 10):
        Cn = C(n)
        assert Cn.order() == n
        assert Cn.center_size() == n
        verify_formula(Cn)

    for n in range(3, 10):
        Dn = D(n)
        assert Dn.order() == 2 * n
        assert Dn.center_size() == 1 if n % 2 == 1 else 2
        verify_formula(Dn)

    for n in (3, 4, 5):
        Qn = GQ(n)
        assert Qn.order() == 2**n
        assert Qn.center_size() == 2
        verify_formula(Qn)

    for n in range(3, 6):
        Sn = S(n)
        assert Sn.order() == factorial(n)
        assert Sn.center_size() == 1
        verify_formula(Sn)

    for n in range(3, 6):
        An = A(n)
        assert An.order() == factorial(n) // 2
        assert An.center_size() == 3 if n == 3 else 1
        verify_formula(An)

    for gps in [
        [C(2), C(2)],
        [S(3), S(3)],
        [A(3), A(3), C(2)],
        [GQ(3), C(2)],
    ]:
        P = dir_prod(gps)
        assert P.order() == prod((G.order() for G in gps))
        assert P.center_size() == prod((G.center_size() for G in gps))
        verify_formula(P)

    for n in (3, 5):  # Sadly these tests are slow for larger n.
        SL2n = SL2(n)
        PSL2n = PSL2(n)

        SL2n_size = prod(
            (p ** (2 * n) - p ** (2 * n - 2)) * (p ** (2 * n) - p ** (2 * n - 1))
            for p, n in factor(n).items()
        ) // euler_phi(n)

        assert SL2n.order() == SL2n_size
        assert PSL2n.order() == SL2n_size // 2
        assert SL2n.center_size() == 2
        assert PSL2n.center_size() == 1
        verify_formula(SL2n)


def test_all():
    test_free_group_identities()
    test_subgroup_creation()
    test_subgroup_new_generators()
    test_subgroup_element_containement()
    test_normal_subgroup()
    test_finite_index_subgroup()
    test_finite_groups()
