import itertools
from math import factorial, prod
from typing import List


from finite_group import FiniteGroup
from finite_group_presentations import A, C, D, GL2, GQ, PSL2, S, SL2, Unip, dir_prod
from free_group import FreeGroup, FreeGroupElement, commutator
from utils import is_power_of, factor, euler_phi


def test_free_group_identities():
    F = FreeGroup(("a", "b", "c"))
    a, b, c = F.gens()
    x, y, z = (a * b * ~a * b * c**2, b ** (-3) * c * a * b, a * b * c**5 * ~a)
    e = F.identity()

    # Group axioms
    assert x * e == e * x == x
    assert x * ~x == ~x * x == e
    assert (x * y) * z == x * (y * z)
    assert (x * y) ** (-1) == y ** (-1) * x ** (-1)

    # Exponentiation
    assert x**5 == x * x * x * x * x
    assert y ** (-2) == ~y * ~y

    # Conjugation
    assert x.conjugate(y) == y * x * ~y
    assert x.conjugate(e) == x
    assert e.conjugate(x) == e
    assert (x * y).conjugate(z) == x.conjugate(z) * y.conjugate(z)
    assert x.conjugate(y * z) == x.conjugate(z).conjugate(y)

    # Commutators
    c = commutator
    assert c(x, y) == x * y * ~x * ~y
    assert c(x, y) == ~c(y, x)
    assert c(x * y, z) == c(x, c(y, z)) * c(y, z) * c(x, z)
    assert (
        c(~x, ~y) == (~x) ** 2 * c(x, ~y) * (~y) ** 2 * c(y, x) * x**2 * c(~x, y) * y**2
    )

    # Jacobi identity
    assert (
        c(z.conjugate(y), c(x, y))
        * c(y.conjugate(x), c(z, x))
        * c(x.conjugate(z), c(y, z))
        == e
    )


def test_subgroup_creation():
    F = FreeGroup(("a", "b"))
    words = list(F.__iter__(max_len=4))
    for w1, w2 in itertools.combinations(words, 2):
        F.subgroup([w1, w2])


def test_subgroup_new_generators():
    # Tests that the subgroup manages to form a basis, that generates the original and is no longer than it.
    # TODO: Add proofs the new generators are generated by the originals.

    # I am not sure how to test that the new generators are free.
    # Technically, returning the original generators would satisfy this test...

    F = FreeGroup(("a", "b"))
    a, b = F.gens()

    lst: List[List[FreeGroupElement]] = [
        [a, b],
        [a, b ** (-10)],
        [a * b, b * a],
        [(a * b) ** 2, a],
        [(a * b) ** 3, b],
        [b * a * ~b, a**3 * ~b],
        [a**2, b**3, commutator(a, b)],
        [(a * b) ** 10, commutator(a, b) ** 3, b**1, b.conjugate(a)],
        [a**2 * b**3 * a ** (-2), b**3, commutator(a, b.conjugate(a**5))],
    ]

    for gens in lst:
        H = F.subgroup(gens)
        free_gens = H.gens()
        assert len(free_gens) <= len(gens)
        for gen in gens:
            word = H.express(gen)
            assert word is not None
            for g, _ in word:
                assert g in free_gens

            w = F.identity()
            for g, n in word:
                w *= g**n
            assert w == gen


def test_subgroup_element_containement():
    F = FreeGroup(("a", "b"))
    a, b = F.gens()
    x, y = (a**3 * b ** (-2) * a * b**2, a * b * a * b * a * b)

    # contains_element
    assert F.full_subgroup().contains_element(a)
    assert not F.empty_subgroup().contains_element(a)
    assert F.subgroup([x, y]).contains_element(x * y * x ** (-2) * y**3)
    assert not F.subgroup([a**2, b]).contains_element(a)


def test_normal_subgroup():
    F2 = FreeGroup(("a", "b"))
    a, b = F2.gens()

    assert F2.full_subgroup().is_normal_in(F2)
    assert F2.empty_subgroup().is_normal_in(F2)
    assert not F2.subgroup([a]).is_normal_in(F2)
    assert F2.subgroup(
        [a, a.conjugate(b), a.conjugate(b**2), a.conjugate(b**3), b**4]
    ).is_normal_in(F2)

    # Generate S3
    assert F2.normal_subgroup([a**2, b**3, b.conjugate(a) * a]).is_normal_in(F2)


def test_finite_index_subgroup():
    F2 = FreeGroup(("a", "b"))
    a, b = F2.gens()

    # This is S5.
    kernel = F2.normal_subgroup(
        [a**2, b**5, (a * b) ** 4, commutator(a, b) ** 3, commutator(a, b**2) ** 2]
    )
    G = F2 / kernel
    a, b = G.gens()
    assert G.order() == 120

    # This is a 5-cycle.
    H = G.subgroup([a * b * a])
    assert H.order() == 5

    conjugates = H.conjugates_in(G)
    assert H in conjugates

    # There are six 5-syllow subgroups of S5!
    assert len(conjugates) == 6

    for conj in conjugates:
        assert conj.order() == 5

    for gen in G.gens():
        for conj in conjugates:
            assert conj.conjugate(gen) in conjugates
            assert conj.conjugate(~gen) in conjugates

    assert H.core_in(G).is_trivial()


def test_finite_groups():
    # This verifies the sizes of finite groups, and that the ranks of the kernels for them satisfy the formula:
    # rank(N_G) == |G| * (n - 1) + 1, where N_G = ker(F_n -> G).
    def verify_formula(G: FiniteGroup):
        assert G.kernel.rank() == G.order() * (G.free_group.rank() - 1) + 1

    for n in range(2, 10):
        Cn = C(n)
        assert Cn.order() == n
        assert Cn.center() == Cn
        verify_formula(Cn)

    for n in range(3, 10):
        Dn = D(n)
        assert Dn.order() == 2 * n
        assert Dn.center().order() == 1 if n % 2 == 1 else 2
        verify_formula(Dn)

    for n in (3, 4, 5):
        Qn = GQ(n)
        assert Qn.order() == 2**n
        assert Qn.center().order() == 2
        verify_formula(Qn)

    for n in range(3, 6):
        Sn = S(n)
        assert Sn.order() == factorial(n)
        assert Sn.center().order() == 1
        verify_formula(Sn)

    for n in range(3, 6):
        An = A(n)
        assert An.order() == factorial(n) // 2
        assert An.center().order() == 3 if n == 3 else 1
        verify_formula(An)

    for gps in [
        [C(2), C(2)],
        [S(3), S(3)],
        [A(3), A(3), C(2)],
        [GQ(3), C(2)],
    ]:
        P = dir_prod(gps)
        assert P.order() == prod((G.order() for G in gps))
        assert P.center().order() == prod((G.center().order() for G in gps))
        verify_formula(P)

    for n in (3, 5):  # Sadly these tests are slow for larger n.
        SL2n = SL2(n)
        PSL2n = PSL2(n)

        SL2n_size = prod(
            (p ** (2 * n) - p ** (2 * n - 2)) * (p ** (2 * n) - p ** (2 * n - 1))
            for p, n in factor(n).items()
        ) // euler_phi(n)

        assert SL2n.order() == SL2n_size
        assert PSL2n.order() == SL2n_size // 2
        assert SL2n.center().order() == 2
        assert PSL2n.center().order() == 1
        verify_formula(SL2n)

    for q in (2, 3, 4, 5):
        GL2q = GL2(q)
        GL2q_size = (q**2 - 1) * (q**2 - q)
        assert GL2q.order() == GL2q_size
        Z = GL2q.center()
        assert Z.order() == q - 1 and Z.is_cyclic()
        verify_formula(GL2q)


def test_relative_subgroups():
    F2 = FreeGroup(("a", "b"))
    a, _b = F2.gens()
    H1 = F2.subgroup([a])
    H2 = F2.subgroup([a**5])
    assert H1.is_normal_in(H1) and H2.is_normal_in(H2)
    assert H2.is_normal_in(H1)
    assert H1.has_finite_index_in(H1) and H2.has_finite_index_in(H2)
    assert H2.has_finite_index_in(H1)


def test_A4_subgroup():
    A4 = A(4)
    a, b = A4.gens()
    assert (a * b).order() == 2  # A permutation of type (1 2)(3 4)
    V = A4.subgroup([a * b]).normalizer_in(
        A4
    )  # {e, (1 2)(3 4), (1 3)(2 4), (1 4)(2 3)}
    assert V.order() == 4
    assert all(x.order() in (1, 2) for x in V.elements())
    assert (A4 / V).order() == 3
    assert V.centralizer_in(A4) == V


def test_p_sylow():
    for G in [A(4), S(4), D(8), GQ(4), SL2(3)]:  # , PSL2(5)]:
        for p in [2, 3, 5, 7]:
            P = G.sylow_subgroup(p)
            assert G.contains_subgroup(P)
            assert is_power_of(P.order(), p)
            assert (G.order() // P.order()) % p != 0

            # The amount of conjugations
            assert len(P.conjugates_in(G)) % p == 1

            assert P.is_nilpotent()


def test_solvable_and_nilpotent_lengths():
    G = S(4)
    assert G.is_solvable()
    assert G.derived_length() == 3
    assert not G.is_nilpotent()

    P = Unip(4, 3)
    assert P.order() == 3**6
    assert P.nilpotency_class() == 3


def test_simple_group():
    assert C(2).is_simple()
    assert not C(4).is_simple()
    assert not A(4).is_simple()
    assert A(5).is_simple()
    assert PSL2(7).is_simple()


def test_all():
    test_free_group_identities()
    test_subgroup_creation()
    test_subgroup_new_generators()
    test_subgroup_element_containement()
    test_normal_subgroup()
    test_finite_index_subgroup()
    test_finite_groups()
    test_relative_subgroups()
    test_A4_subgroup()
    test_p_sylow()
    test_solvable_and_nilpotent_lengths()
    test_simple_group()
