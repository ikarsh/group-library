import itertools
from typing import List, Tuple
from free_group import (
    FreeGroup,
    FreeGroupElement,
    commutator,
)
from subgroup_of_free_group import SubgroupOfFreeGroup


def invariant(H: SubgroupOfFreeGroup):
    N = H.normalization()
    return N.rank() - N.index() * N.free_group.rank()


def verify_invariant(H: SubgroupOfFreeGroup, steps: int = 1):
    N = H.normalization()
    n = N.free_group.rank()
    F = FreeGroup(n + steps)
    F_gens = F.gens()
    old_gens, new_gens = F_gens[:n], F_gens[n:]

    relations: List[FreeGroupElement] = []
    for g in N.gens():
        relations.append(g.substitute(F, old_gens))
    for gen in new_gens:
        relations.append(gen)

    new_H = F.subgroup(relations)

    for gen in new_gens:
        for gi in N.coset_representatives():
            if gi.is_identity():
                assert gen in relations
                continue
            gi = gi.substitute(F, old_gens)
            relations.append(gi * gen * ~gi)

    new_N = F.subgroup(relations)
    assert (
        new_N.is_normal()
        and new_N.contains_subgroup(new_H)
        and new_N.equals_subgroup(new_H.normalization())
        and new_N.rank() == N.rank() + steps * N.index()
    )
    assert new_H.normalization().rank() == new_N.rank()
    assert invariant(new_H) == invariant(H)


def C(n: int) -> SubgroupOfFreeGroup:
    F = FreeGroup(("a",))
    (a,) = F.gens()
    return F.subgroup([a**n])


def prod(gps: List[SubgroupOfFreeGroup]) -> SubgroupOfFreeGroup:
    F = FreeGroup(
        tuple(f"a{i}_{j}" for i in range(len(gps)) for j in range(gps[i].rank()))
    )
    relations: List[FreeGroupElement] = []

    def gens(i: int) -> Tuple[FreeGroupElement, ...]:
        return tuple(
            FreeGroupElement.from_str(F, f"a{i}_{j}") for j in range(gps[i].rank())
        )

    for i, gp in enumerate(gps):
        for gen in gp.gens():
            relations.append(gen.substitute(F, gens(i)))

    for (i, gpi), (j, gpj) in itertools.combinations(enumerate(gps), 2):
        for geni in gpi.free_group.gens():
            for genj in gpj.free_group.gens():
                relations.append(
                    commutator(geni.substitute(F, gens(i)), genj.substitute(F, gens(j)))
                )

    return F.subgroup(relations)


def D(n: int) -> SubgroupOfFreeGroup:
    F = FreeGroup(("a", "b"))
    a, b = F.gens()
    return F.subgroup([a**n, b**2, a.conjugate(b) * a])


def Q8() -> SubgroupOfFreeGroup:
    """
    Source: https://proofwiki.org/wiki/Quaternion_Group/Group_Presentation
    """
    F = FreeGroup(("a", "b"))
    a, b = F.gens()
    return F.subgroup([a**4, a ** (-2) * b**2, a * b * a * ~b])


def S(n: int) -> SubgroupOfFreeGroup:  # Generated by two-cycle and n-cycle
    """
    Source: https://math.stackexchange.com/questions/3972026/what-are-the-relations-in-this-presentation-of-s-n
    """
    F = FreeGroup(("a", "b"))
    a, b = F.gens()
    return F.subgroup(
        [a**2, b**n, (a * b) ** (n - 1), commutator(a, b) ** 3]
        + [commutator(a, b**k) ** 2 for k in range(2, n // 2 + 1)]
    )


def S_(n: int) -> SubgroupOfFreeGroup:  # Generated by two-cycles
    """
    Source: https://warwick.ac.uk/fac/sci/maths/people/staff/fbouyer/presentation_of_group.pdf
    """
    F = FreeGroup(tuple(f"a{i}" for i in range(n - 1)))
    gens = F.gens()
    relations: List[FreeGroupElement] = []
    for g in gens:
        relations.append(g**2)
    for (i, g1), (j, g2) in itertools.combinations(enumerate(gens), 2):
        assert i != j
        if abs(i - j) == 1:
            relations.append((g1 * g2) ** 3)
        else:
            relations.append(commutator(g1, g2))
    return F.subgroup(relations)


def A(n: int) -> SubgroupOfFreeGroup:  # Generated by (1, 2, i)
    """
    Source: https://math.stackexchange.com/questions/122720/presentations-for-alternating-groups
    """
    F = FreeGroup(n - 2)
    gens = F.gens()
    relations: List[FreeGroupElement] = []
    for g in gens:
        relations.append(g**3)
    for g, h in itertools.combinations(gens, 2):
        relations.append((g * h) ** 2)
    return F.subgroup(relations)
